I"ä0<p>Ah programming languages. They‚Äôre a common subject of inquery: What
language should I learn? How do I rate my language knowledge? How easy
is it to learn a new language? They‚Äôre used as requirements on job
postings, as credentials on a resume and to maybe write some code
every so often.</p>

<p>Let‚Äôs dive into the process of learning a new language, from syntax to
full fluency.</p>

<h1 id="quantifying-learning">Quantifying Learning</h1>

<p>There‚Äôs an often echoed sentiment that programming languages, past the
first or second one, are all the same and easy to learn. I don‚Äôt think
this is wholly inaccurate, but I do find this a vast
oversimplification. For one, it breezes over what it means to learn a
language.</p>

<p>Learning a language can mean extremely different things depending on
your general level of experience, who you‚Äôre speaking with, and the
language itself. For instance, if you‚Äôre a student, I think it‚Äôs
perfectly acceptable to claim that you know a language if you‚Äôve taken
a course or two in it and written a few programs in it. Most likely
people aren‚Äôt going to ask a student in college the ins and outs of
Java generic variance. If they do, that‚Äôs on them. However a
professional developer should probably have at least a few months
worth of full time, professional experience in a language before they
claim proficiency.</p>

<p>This means that as you progress in your career, you may actually put
<em>less</em> languages down on your resume.</p>

<p>The language also matters. Python and Java show up on practically
every student‚Äôs resume. Because it‚Äôs so common, people will just see
it as a student putting their two terms of Java on their resume and
don‚Äôt verify it. But if you were to put Haskell, a language that‚Äôs
somewhat infamous for being challenging, on your resume, there‚Äôs a
chance a dev will want to see if you <em>really</em> know Haskell.</p>

<p>Often with programming languages, there‚Äôs a concept that is absolutely
key to a given language. With Haskell this concept is
<a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">monads</a>. In
C, it‚Äôs pointers. In Rust, it‚Äôs ownership. If you don‚Äôt understand
these core concepts, I wouldn‚Äôt recommend claiming you know the
language.</p>

<p>With other languages, there‚Äôs sometimes a large surface area. C++ is a
gigantic language. In that case, I‚Äôd try to specify what subset you
know. Do you know modern C++ (C++11 and onward)? Do you know the
original C with classes? Do you know modern JavaScript (ES6+)? Or just
the basic <code class="highlighter-rouge">function</code>/<code class="highlighter-rouge">var</code> style? These are basically different
languages so it helps to clarify.</p>

<h1 id="bare-minimum">Bare Minimum</h1>

<p>With these ideas in mind, what‚Äôs the bare minimum before you can go
around proclaiming you know XYZ lang?</p>

<p>To start, you should know the basic syntax, i.e. how to define a
function, how to write a Hello World, etc. You should know the general
categorization of the language, such as static vs dynamic typing,
imperative vs functional, scripting vs systems, etc. You should be
able to write a simple project in the language, perhaps a solid one
page command line tool or a simple web server.</p>

<p>When people claim learning a language is easy, this is generally what
they mean. It‚Äôs not hard to learn the syntax, categorization and
enough semantics to write a simple program. Especially since most
languages look similar, so syntax is easily learned. And if you stick
to imperative languages, most of them have quite similar semantics.</p>

<p>However there are non-imperative languages, which is where the ‚Äúlearn
a new language in a day‚Äù proclamation breaks down. To give a real life
language analogy, romance languages are quite similar‚Äîit‚Äôs not
terribly hard to learn French if you speak Italian or vice versa. But
you can‚Äôt say that all languages are easy to pick up just because
you‚Äôve only encountered romance languages. Somewhere out there Chinese
is lurking and it ain‚Äôt easy.</p>

<p>I highly recommend learning a different paradigm than imperative as
it‚Äôll teach you a completely new style and a new approach to
programming. Functional programming is the classic alternative, but
logic programming languages like Prolog are also very interesting.</p>

<p>If you‚Äôre at the bare minimum stage and applying for your first job, I
belive it‚Äôs perfectly fine to put down that you know the language. You
may stumble a bit in an interview, but that‚Äôs perfectly normal.</p>

<p>However if you‚Äôre beyond your first or second internship/job, you
should be a little more strict with yourself on language
proficiency. Perhaps put a caveat such as ‚Äú(familiar)‚Äù or ‚Äú(learning)‚Äù
next to the language.</p>

<h1 id="getting-comfortable">Getting Comfortable</h1>

<p>After the bare minimum, there‚Äôs the stage where you get comfortable in
a language. This is where you start to learn the idioms and ideas
behind the language. You start to understand that there‚Äôs a particular
way in which programmers of this language analyze and solve problems.</p>

<p>I faced this myself when I learned Ruby. I was at my first internship
where I was tasked to write a simple scraper in Ruby. I learned Ruby‚Äôs
syntax and semantics, then wrote a first draft quickly. I figured that
past a few code refinements, the program should be ready for
production. However when I showed it to my mentors, they quickly
pointed out that I had written the code as if I were writing Python or
Java in Ruby. For instance, I would have code such as:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if name == nil
  return nil
end
</code></pre></div></div>

<p>Which, while semantically correct, is not quite idiomatic. The
idiomatic version, as pointed out to me, goes:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return nil if name.nil?
</code></pre></div></div>

<p>This may not seem like a huge difference. But idioms do matter. Every
experienced Ruby programmer will understand both lines of code, but
they‚Äôll immediately recognize the idiomatic version, whereas with the
first version they might take a second to scan. Not to mention the
second version is shorter and elegant. It‚Äôs the difference between
writing a sentence that, while technically correct, is awkwardly
phrased and a little ungainly, versus writing a clear and concise
sentence.</p>

<p>If I‚Äôm reading code that clearly does not follow the idioms of the
language, I‚Äôm going to be a lot less confident in the author‚Äôs skill
in this language, and therefore apply a lot more scrutiny.</p>

<p>A good place to pick up idioms are style guides. Plenty of big
companies have style guides for certain languages. Google has <a href="http://google.github.io/styleguide/">a
few</a>. Some languages come with
their own principles like
<a href="https://golang.org/doc/effective_go.html">Go</a>,
<a href="https://www.python.org/dev/peps/pep-0008/">Python</a>, and
<a href="https://kotlinlang.org/docs/reference/coding-conventions.html">Kotlin</a>.</p>

<p>I‚Äôd recommend that you be at this level when you apply for a full time
job with a language on your resume. A properly trained developer
should write idiomatic, well written code.</p>

<h1 id="developing-opinions">Developing Opinions</h1>

<p>A classic interview question posed by, I believe, Steve Yegge asks
people for their favorite language, then their favorite and least
favorite thing about it. I really like this question. A good sign that
someone knows a language is when they can critique it in a well
thought out, reasonable manner. By that I don‚Äôt mean the usual ‚ÄúOMG JS
sucks so much!!!‚Äù that you find online. A proper critique of a
language understands that every language has its strong areas and its
weak areas. That every language is fundamentally a tool that can be
used in certain situations and not in other situations.</p>

<p>If you find a language utterly perfect, or if you find it utterly
irredeemable, you don‚Äôt really know the language.</p>

<p>Bjarne Stroustrup famously said: ‚ÄúThere are only two kinds of
languages: the ones people complain about and the ones nobody uses.‚Äù
Use a language, find something to complain about.</p>

<p>Critiquing a language gets easier as you know more languages. You can
compare the different paradigms, the different tooling setups, the
different syntax. What you‚Äôll inevitably find is that you probably
don‚Äôt prefer one exact language. You prefer this element of Rust, that
element of Go, this part of Ruby, etc. Which is bittersweet, since
you‚Äôll never get the perfect language.</p>

<p>Another important part of critiquing is that you start to carve out a
subset of the language that you like and prefer. Perhaps you start to
avoid multiple inheritance. Maybe you learn to not use <code class="highlighter-rouge">var</code> in
JavaScript. Some people believe that learning a language entails
learning all the features and neat little edgecases. Which isn‚Äôt
wrong. The next step is to take all of that knowledge and select only
the elements you like.</p>

<h1 id="diving-underneath">Diving Underneath</h1>

<p>If you truly want to understand a language, you need to dive under the
hood. What‚Äôs great is that practically every language has an open
source implementation out there. Clone it, read the source code, and
tinker with it.</p>

<p>You can learn a lot from implementation. Some languages are impossible
to fully understand without understanding their implementation. I
wouldn‚Äôt trust a C++ programmer who doesn‚Äôt understand object memory
layouts or vtables. I wouldn‚Äôt trust a Java programmer who doesn‚Äôt
understand garbage collection.</p>

<p>A lot of languages are implemented in themselves, a process called
bootstrapping. Often times this implementation is a great example of a
large scale codebase in this language.</p>

<p>However contributing to the implementation isn‚Äôt always the same as
knowing the language. If the implementation is not in the language,
then you‚Äôre not writing in the language. Plus compiler or interpreter
writing is very different than normal development. You may end up with
a different set of idioms and best practices.</p>

<h1 id="what-language-should-i-learn">What Language Should I Learn?</h1>

<p>Yeah yeah yeah you say. Who cares about working on a compiler? I want
to get hired. What languages should I learn to do that?</p>

<p>Well, anything really. As long as you‚Äôre learning a language and
writing code in it, you‚Äôll be hireable. If you learn more common
languages like Python and Java, there‚Äôs no shortage of jobs that use
both. If you learn something more obscure like Haskell or Rust, you‚Äôll
get some solid nerd cred from it. People worry too much about the
right language. They worry that if they don‚Äôt learn the precise
language that the company is hiring for, they won‚Äôt get the
job. That‚Äôs not true at all. Unless the company is hiring for a senior
position who will have major architecture control, they shouldn‚Äôt care
that much about language.</p>

<p>I believe Joel Spolsky said something along the lines of if you hire a
top notch programmer with no experience in Ruby for a job, in a year
you‚Äôll have a top notch programmer with a year‚Äôs experience in
Java. If you hire a mediocre programmer with 4 years of Java, in a
year you‚Äôll have a mediocre programmer with 5 years of Java. Guess
who‚Äôs gonna be the better hire?</p>

<p>Part of the problem is that people take job listings too seriously. If
a job listing says it requires 2 years of Java for an entry level
position, it‚Äôs not <em>really</em> asking for 2 years. It‚Äôs more a ‚Äúit‚Äôd be
nice if you had around 2 years‚Äù</p>

<p>Large companies often use several different languages anyways. Just
apply and find out.</p>

<p>If you‚Äôre <em>still</em> unsatisfied with this response, and just need a damn
answer, learn JavaScript. People complain endlessly about it but you
can‚Äôt find a language with more usecases and more jobs. You can write
mobile applications, front end, back end, even machine learning in
JS. Plus modern JS is a quite nice language.</p>

<p>If that offends your sensibilities, then great, learn whatever
language you believe is better.</p>
:ET