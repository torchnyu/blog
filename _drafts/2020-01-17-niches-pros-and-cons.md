I've hesitated to write this post. Not because it'd be controversial
or because it'd get me in trouble. But because I'm concerned that
people might misconstrue or exaggerate the message.

Let me be unambiguous here:

### You should keep learning all aspects of computer science

### You shouldn't feel obligated to stick to a particular area

### There is no one magical area that will get you hired. No, not even ML.

With that out of the way, let's get on with the post.

I'm interested in programming languages and compilers. I find them
really fascinating for a variety of reasons. They're a foundational
aspect of programming; they influence how people think about their
problems; and they have a host of cool engineering challenges.

I became interested in programming languages in my freshman year of
college. I stumbled upon [Crafting
Interpreters](https://craftinginterpreters.com/), started coding along
and got hooked. Since then I've attended [workshops on programming
languages](https://school.racket-lang.org/), tried to work on the Ruby
interpreter, (slowly) built my own compiler and finally got a job
working on a compiler. In short, I found a niche.

My niche has helped me a lot. I've gotten good at an area, moreso than
your average undergrad. I've managed to connect with people in my
field and learn from them. And the benefit you've all been waiting
for, I've managed to get jobs out of it.

It becomes a lot easier to sell yourself when you can confidently say
that you are in the few hundred or so who know this area. I can debug
WebAssembly by reading the hex. I've read the WebAssembly spec and
understand how it does first class functions. I understand the nitty
gritty bits of compilers like closure conversion.

Of course, gaining this knowledge takes work. I had to learn from
different sources, work on side projects, bang my head against the
wall (proverbally), etc. But it's not an impossible amount of
work. Indeed, I've met other college students who have done the same
or more. It's the focus and specificity of the work that makes it
unusual.

I'll give an example. I worked on a compiler for my language, Saber,
for a while. It's still not fully working but I managed to get a few
core concepts done like strings, structs, closures, etc. I sent an
email to the Cloudflare CEO explaining that I had written this
compiler and that I was interested in working at Cloudflare due to
their work on WebAssembly and Rust. To my surprise, he responded! And
I got the job!

This may seem extraordinary, but it's actually not. For one, CEOs
respond to their email a lot more than you'd expect. I'm 2/3 for
emailing billion dollar company CEOs (1/1 for trillion :D). And
remember, this is a niche. There's only a few hundred[^1] people who
have experience with WebAssembly and writing compilers and writing
Rust. The majority of them are already in these positions. You could
train a regular intern for this, but that'd likely take a few months
between learning Rust, WebAssembly and compiler techniques.

Hiring someone who knows this exact niche and can start immediately is
on par with saving a few thousand dollars in training, recruiting,
etc.

[^1]: Generously. I'd estimate anywhere from 100-300

Now niches do also limit where your experience is strictly
relevant. But that's not a huge problem. Most companies don't hire
based on what they exactly need this second. If you had a position
open for a Java engineer using Spring and Android, you wouldn't wait
to hire the one person who is an open source contributor to Spring,
Android and wrote a Java compiler. But, if said person did apply,
you'd probably snap them up pretty quickly, no?

Think of this as a multiplier. If you happen to hit the right buttons,
you'll get a 10x boost on hireability. If you don't, you'll just be a
normal candidate.

The other great part about having a niche is that you can demonstrate
your competency by just talking. The moment I start talking about
WebAssembly internals, or Hindley Milner typechecking or parser error
recovery, the interviewer understands that I know my stuff. After
that, they're much more likely to give me pass on my leetcode
performance.

How do you get a niche? The most natural way is to stumble upon
something that seems interesting. Maybe this happens in class. Maybe
it happens on reddit or Hacker News. It could be a blog post on
embedded operating systems or a lecture on zero-knowledge proofs. One
you have that interest, you can go off and do some research. Ask
professors, read papers, skim some textbooks.

If you can't find a niche organically, then you can still explore
different areas. First, ignore all the web/iOS/systems,
whatever. That's still too broad. Get very very very specific. Learn
how one particular operating system/language/library works. Read the
source code. Don't be afraid to go low level too. If you have to trawl
through hex or read assembly, so be it. Contact people in that field
and learn from them.

It's okay if you make slow progress. I've inched along in PL for
years. I've gone weeks, months without touching my compiler. What's
mattered is that I came back to it and kept working. Even if it took
me 3 years when someone else took 3 months, I still made it.
